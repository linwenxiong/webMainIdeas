 1. 组合式api替换掉了；


题外话：vue2中无法监听数组变化的解决办法？
```javascript
var vm= new Vue({
    data:{
        obj:{ name:'张三'}  //对象
    }
})
// 当添加新属性的时候，无法被监听到
vm.obj.age = 20
```
# object.defineProperty 缺陷
- 比如说对象，它只能劫持预先定义好的属性，对于新增的属性，object.defineProperty 无法侦听到变化。只能通过$set()方法去添加。
- 还有数组也是无法修改某项值的，只能通过数组的api或者set()方法去修改；


原因：Vue无法侦听到新添加的属性的变化是因为Vue.js只在实例化Vue对象时对已经定义的属性进行侦听，而不是对后来添加的属性进行侦听。也就是说，当你在运行时添加新属性时，需要使用Vue.set()方法来添加一个新属性并使其成为响应式属性。

用push， 或者set()方法可以解决。


# Vue 2 面对的问题
- 代码架构 
- 性能优化空间
- API在大型项目中的可维护性
- 浏览器版本限制

# vue3的目标
- 代码架构
    - 迁移到 TypeScript+自动生成类型声明
    - 重新设计内部模块分层
    - 为以后的长期维护打好基础
- 性能
    - VDOM 算法重构
    - 结合编译器对虚拟 VDOM 进行优化
    - 优化组件实例化开销
- API
    - 引入对重构、复用、类型推导更友好的新 API
- 浏览器
    - 语言支持最低要求 ES2015+



为什么不直接操作dom？而是使用js去描述这个DOm对象？
- 因为在一个dom身上属性是非常多的，直接操作Dom是非常影响性能的，而操作js是非常快的，
所有就有了虚拟dom这个概念，有了虚拟dom之后，还可以去做一个算法的优化，比如里面有很多dom
可以做一些复用，这个个时候就出来了diff算法了

# 有key
 - 相同的节点会复用
头和头比，尾和尾比，如果新增了节点，就是挂载新节点，
如果少了节点，就卸载节点

# 没有key
没有key情况下，新节点会直接替换到旧节点，会造成性能上的浪费；